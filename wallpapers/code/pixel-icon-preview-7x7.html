<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>7x7 Thinking Animations</title>
<style>
  * { box-sizing: border-box; }
  body {
    background: #0a0a0a;
    color: #eee;
    font-family: system-ui, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 32px;
    gap: 28px;
  }
  h2 { margin: 0; font-size: 18px; color: #aaa; font-weight: 500; }
  .grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 20px;
    width: 100%;
    max-width: 1600px;
  }
  .card {
    background: #111;
    border: 1px solid #222;
    border-radius: 12px;
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .card-header h3 { margin: 0; font-size: 14px; color: #ccc; font-weight: 500; }
  .card p { margin: 0; font-size: 11px; color: #555; line-height: 1.4; }
  .sizes { display: flex; gap: 14px; align-items: flex-end; }
  .sizes .item { display: flex; flex-direction: column; align-items: center; gap: 3px; }
  .sizes label { font-size: 9px; color: #444; }
  .controls-row {
    display: flex; gap: 8px; align-items: center; flex-wrap: wrap;
  }
  .controls-row label {
    font-size: 11px; color: #555; display: flex; align-items: center; gap: 4px;
  }
  .controls-row input[type="range"] { width: 60px; height: 14px; }
  .controls-row input[type="color"] {
    width: 22px; height: 22px; border: 1px solid #333;
    border-radius: 4px; padding: 0; cursor: pointer; background: none;
  }
  .controls-row input[type="color"]::-webkit-color-swatch-wrapper { padding: 2px; }
  .controls-row input[type="color"]::-webkit-color-swatch { border-radius: 2px; border: none; }
  .copy-btn, .play-btn {
    background: #1a1a1a; color: #888; border: 1px solid #2a2a2a;
    padding: 3px 10px; border-radius: 5px; cursor: pointer; font-size: 11px;
    transition: all 0.15s;
  }
  .copy-btn:hover, .play-btn:hover { background: #252525; color: #ccc; }
  .copy-btn.copied { background: #1a3a1a; color: #6c6; border-color: #2a4a2a; }
  .play-btn.playing { background: #1a2a3a; color: #6af; border-color: #2a3a5a; }
  .card.paused { opacity: 0.5; }
  .card.paused:hover { opacity: 0.75; }
  .val { font-size: 10px; color: #444; min-width: 24px; }
</style>
</head>
<body>

<h2>7x7 Thinking Animations</h2>
<div class="grid" id="cards"></div>

<script>
const DPR = window.devicePixelRatio || 1;
const GRID = 7;
const CENTER = 3;
const RENDER_SIZES = [16, 20, 48, 120];

function makeCanvas(size) {
  const c = document.createElement("canvas");
  c.width = size * DPR;
  c.height = size * DPR;
  c.style.width = size + "px";
  c.style.height = size + "px";
  return c;
}

function hexToRgb(hex) {
  return {
    r: parseInt(hex.slice(1,3), 16),
    g: parseInt(hex.slice(3,5), 16),
    b: parseInt(hex.slice(5,7), 16),
  };
}

function drawLEDGrid(ctx, size, cellStates) {
  const s = size * DPR;
  ctx.clearRect(0, 0, s, s);

  const gapRatio = 0.18;
  const cellSize = s / (GRID + (GRID - 1) * gapRatio);
  const gap = cellSize * gapRatio;
  const total = GRID * cellSize + (GRID - 1) * gap;
  const offset = (s - total) / 2;
  const r = cellSize * 0.28;

  for (let gy = 0; gy < GRID; gy++) {
    for (let gx = 0; gx < GRID; gx++) {
      const state = cellStates.get(gx + "," + gy);
      if (!state || state.brightness < 0.05) continue;
      const px = offset + gx * (cellSize + gap) + cellSize / 2;
      const py = offset + gy * (cellSize + gap) + cellSize / 2;
      const glowR = cellSize * 2.2;
      const alpha = state.brightness * 0.35;
      const grad = ctx.createRadialGradient(px, py, 0, px, py, glowR);
      grad.addColorStop(0, `rgba(${state.r},${state.g},${state.b},${alpha})`);
      grad.addColorStop(0.5, `rgba(${state.r},${state.g},${state.b},${alpha * 0.3})`);
      grad.addColorStop(1, `rgba(${state.r},${state.g},${state.b},0)`);
      ctx.fillStyle = grad;
      ctx.fillRect(px - glowR, py - glowR, glowR * 2, glowR * 2);
    }
  }

  for (let gy = 0; gy < GRID; gy++) {
    for (let gx = 0; gx < GRID; gx++) {
      const px = offset + gx * (cellSize + gap);
      const py = offset + gy * (cellSize + gap);
      const state = cellStates.get(gx + "," + gy);
      const b = state ? state.brightness : 0;
      ctx.beginPath();
      ctx.roundRect(px, py, cellSize, cellSize, r);
      if (b > 0.03) {
        ctx.fillStyle = `rgb(${Math.round(state.r*(0.3+0.7*b))},${Math.round(state.g*(0.3+0.7*b))},${Math.round(state.b*(0.3+0.7*b))})`;
        ctx.fill();
        if (b > 0.4) {
          const hx = px + cellSize / 2, hy = py + cellSize / 2;
          const hGrad = ctx.createRadialGradient(hx, hy, 0, hx, hy, cellSize * 0.35);
          hGrad.addColorStop(0, `rgba(255,255,230,${b * 0.6})`);
          hGrad.addColorStop(1, `rgba(255,255,230,0)`);
          ctx.fillStyle = hGrad;
          ctx.beginPath();
          ctx.roundRect(px, py, cellSize, cellSize, r);
          ctx.fill();
        }
      } else {
        ctx.fillStyle = "#131312";
        ctx.fill();
      }
    }
  }
}

function col(color, brightness) {
  return { ...color, brightness };
}

// ============================================================
// ANIMATION DEFINITIONS
// Each has: desc, params (with defaults), fn(t, params, color)
// ============================================================

const ANIM_DEFS = {

Ripple: {
  desc: "Concentric rings pulse outward from center",
  params: {
    speed:   { min: 0.3, max: 5, step: 0.1, default: 1.8 },
    spacing: { min: 0.3, max: 2, step: 0.1, default: 0.8 },
    falloff: { min: 0, max: 0.6, step: 0.05, default: 0.15 },
  },
  fn(t, p, c) {
    const cells = new Map();
    const phase = (t * p.speed) % 4;
    for (let gy = 0; gy < GRID; gy++) {
      for (let gx = 0; gx < GRID; gx++) {
        const dist = Math.abs(gx - CENTER) + Math.abs(gy - CENTER);
        const wave = phase - dist * p.spacing;
        const b = Math.max(0, Math.sin(wave * Math.PI) * Math.exp(-dist * p.falloff));
        if (b > 0.02) cells.set(gx+","+gy, col(c, b));
      }
    }
    return cells;
  },
  code(p, hex) {
    return `// Ripple — speed: ${p.speed}, spacing: ${p.spacing}, falloff: ${p.falloff}, color: "${hex}"
const phase = (t * ${p.speed}) % 4;
for (let gy = 0; gy < 7; gy++) {
  for (let gx = 0; gx < 7; gx++) {
    const dist = Math.abs(gx - 3) + Math.abs(gy - 3);
    const wave = phase - dist * ${p.spacing};
    const b = Math.max(0, Math.sin(wave * Math.PI) * Math.exp(-dist * ${p.falloff}));
    if (b > 0.02) setCell(gx, gy, b);
  }
}`;
  },
},

Orbit: {
  desc: "Pixels orbit the center at different radii",
  params: {
    speed:  { min: 0.3, max: 5, step: 0.1, default: 2 },
    dots:   { min: 1, max: 6, step: 1, default: 3 },
    radius: { min: 1, max: 3, step: 0.1, default: 2.5 },
    spread: { min: 0, max: 1, step: 0.1, default: 0.7 },
  },
  fn(t, p, c) {
    const cells = new Map();
    cells.set(CENTER+","+CENTER, col(c, 0.4));
    for (let i = 0; i < p.dots; i++) {
      const orbitR = p.radius - (i % 2) * p.radius * (1 - p.spread);
      const spd = p.speed * (1 - (i % 2) * 0.3);
      const offset = (i / p.dots) * Math.PI * 2;
      const angle = t * spd + offset;
      const fx = CENTER + Math.cos(angle) * orbitR;
      const fy = CENTER + Math.sin(angle) * orbitR;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = Math.round(fx) + dx;
          const ny = Math.round(fy) + dy;
          if (nx < 0 || nx >= GRID || ny < 0 || ny >= GRID) continue;
          const dist = Math.sqrt((fx-nx)**2 + (fy-ny)**2);
          const br = Math.max(0, 1 - dist * 0.7) * 0.95;
          if (br < 0.05) continue;
          const key = nx+","+ny;
          const ex = cells.get(key);
          if (!ex || ex.brightness < br) cells.set(key, col(c, br));
        }
      }
    }
    return cells;
  },
  code(p, hex) {
    return `// Orbit — speed: ${p.speed}, dots: ${p.dots}, radius: ${p.radius}, color: "${hex}"
setCell(3, 3, 0.4);
for (let i = 0; i < ${p.dots}; i++) {
  const r = ${p.radius} - (i%2) * ${p.radius} * ${(1-p.spread).toFixed(1)};
  const spd = ${p.speed} * (1 - (i%2)*0.3);
  const angle = t * spd + (i/${p.dots}) * Math.PI * 2;
  const fx = 3 + Math.cos(angle) * r;
  const fy = 3 + Math.sin(angle) * r;
  for (let dy=-1;dy<=1;dy++) for (let dx=-1;dx<=1;dx++) {
    const nx=Math.round(fx)+dx, ny=Math.round(fy)+dy;
    if(nx<0||nx>=7||ny<0||ny>=7) continue;
    setCell(nx, ny, Math.max(0, 1-Math.sqrt((fx-nx)**2+(fy-ny)**2)*0.7)*0.95);
  }
}`;
  },
},

Breathe: {
  desc: "Diamond shape breathes in and out from center",
  params: {
    speed: { min: 0.3, max: 5, step: 0.1, default: 1.8 },
    size:  { min: 1.5, max: 4, step: 0.1, default: 3.2 },
    min:   { min: 0, max: 2, step: 0.1, default: 0.5 },
  },
  fn(t, p, c) {
    const cells = new Map();
    const phase = (Math.sin(t * p.speed) + 1) / 2;
    const radius = p.min + phase * p.size;
    for (let gy = 0; gy < GRID; gy++) {
      for (let gx = 0; gx < GRID; gx++) {
        const dist = Math.abs(gx-CENTER)+Math.abs(gy-CENTER);
        if (dist > radius + 0.5) continue;
        const edge = radius - dist;
        const b = Math.min(1, Math.max(0, edge+0.5)) * (0.4 + 0.6*(1-dist/(p.size+1)));
        if (b > 0.02) cells.set(gx+","+gy, col(c, b));
      }
    }
    return cells;
  },
  code(p, hex) {
    return `// Breathe — speed: ${p.speed}, size: ${p.size}, min: ${p.min}, color: "${hex}"
const phase = (Math.sin(t * ${p.speed}) + 1) / 2;
const radius = ${p.min} + phase * ${p.size};
for (let gy = 0; gy < 7; gy++) {
  for (let gx = 0; gx < 7; gx++) {
    const dist = Math.abs(gx-3) + Math.abs(gy-3);
    if (dist > radius + 0.5) continue;
    const edge = radius - dist;
    const b = Math.min(1, Math.max(0, edge+0.5)) * (0.4 + 0.6*(1-dist/${(p.size+1).toFixed(1)}));
    if (b > 0.02) setCell(gx, gy, b);
  }
}`;
  },
},

Sweep: {
  desc: "Radar beam sweeps around the center with a fade trail",
  params: {
    speed: { min: 0.3, max: 5, step: 0.1, default: 2.2 },
    trail: { min: 0.5, max: 4, step: 0.1, default: 1.8 },
    reach: { min: 1.5, max: 3.5, step: 0.1, default: 3.5 },
  },
  fn(t, p, c) {
    const cells = new Map();
    const angle = t * p.speed;
    for (let gy = 0; gy < GRID; gy++) {
      for (let gx = 0; gx < GRID; gx++) {
        const dx = gx-CENTER, dy = gy-CENTER;
        const dist = Math.sqrt(dx*dx+dy*dy);
        if (dist < 0.5) { cells.set(gx+","+gy, col(c, 0.5)); continue; }
        if (dist > p.reach) continue;
        let diff = ((angle - Math.atan2(dy,dx)) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);
        if (diff < p.trail) {
          const b = (1-diff/p.trail) * 0.9 * Math.min(1, dist/1.5);
          if (b > 0.02) cells.set(gx+","+gy, col(c, b));
        }
      }
    }
    return cells;
  },
  code(p, hex) {
    return `// Sweep — speed: ${p.speed}, trail: ${p.trail}, reach: ${p.reach}, color: "${hex}"
const angle = t * ${p.speed};
for (let gy = 0; gy < 7; gy++) {
  for (let gx = 0; gx < 7; gx++) {
    const dx = gx-3, dy = gy-3;
    const dist = Math.sqrt(dx*dx+dy*dy);
    if (dist < 0.5) { setCell(gx, gy, 0.5); continue; }
    if (dist > ${p.reach}) continue;
    let diff = ((angle - Math.atan2(dy,dx)) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);
    if (diff < ${p.trail}) setCell(gx, gy, (1-diff/${p.trail})*0.9*Math.min(1,dist/1.5));
  }
}`;
  },
},

Wave: {
  desc: "Sine wave of light rolls across the grid",
  params: {
    speed: { min: 0.5, max: 8, step: 0.1, default: 3 },
    freq:  { min: 0.3, max: 3, step: 0.1, default: 1.2 },
    amp:   { min: 0.5, max: 3, step: 0.1, default: 2.2 },
    width: { min: 0.3, max: 1.5, step: 0.1, default: 0.7 },
  },
  fn(t, p, c) {
    const cells = new Map();
    for (let gx = 0; gx < GRID; gx++) {
      const fy = CENTER + Math.sin(gx*p.freq - t*p.speed) * p.amp;
      for (let gy = 0; gy < GRID; gy++) {
        const dist = Math.abs(gy - fy);
        if (dist > 1.5) continue;
        const b = Math.max(0, 1 - dist*p.width);
        if (b > 0.02) cells.set(gx+","+gy, col(c, b));
      }
    }
    return cells;
  },
  code(p, hex) {
    return `// Wave — speed: ${p.speed}, freq: ${p.freq}, amp: ${p.amp}, width: ${p.width}, color: "${hex}"
for (let gx = 0; gx < 7; gx++) {
  const fy = 3 + Math.sin(gx*${p.freq} - t*${p.speed}) * ${p.amp};
  for (let gy = 0; gy < 7; gy++) {
    const dist = Math.abs(gy - fy);
    if (dist > 1.5) continue;
    setCell(gx, gy, Math.max(0, 1 - dist*${p.width}));
  }
}`;
  },
},

Spiral: {
  desc: "Spiral arms radiate outward from center",
  params: {
    speed:  { min: 0.3, max: 5, step: 0.1, default: 2 },
    arms:   { min: 1, max: 5, step: 1, default: 2 },
    twist:  { min: 0.3, max: 3, step: 0.1, default: 1.2 },
  },
  fn(t, p, c) {
    const cells = new Map();
    for (let gy = 0; gy < GRID; gy++) {
      for (let gx = 0; gx < GRID; gx++) {
        const dx = gx-CENTER, dy = gy-CENTER;
        const dist = Math.sqrt(dx*dx+dy*dy);
        if (dist < 0.3 || dist > 3.6) continue;
        const angle = Math.atan2(dy, dx);
        const wave = (Math.sin(angle*p.arms - dist*p.twist + t*p.speed) + 1) / 2;
        const b = wave * (1-dist/4) * 0.9;
        if (b > 0.04) cells.set(gx+","+gy, col(c, b));
      }
    }
    cells.set(CENTER+","+CENTER, col(c, 0.5 + Math.sin(t*3)*0.2));
    return cells;
  },
  code(p, hex) {
    return `// Spiral — speed: ${p.speed}, arms: ${p.arms}, twist: ${p.twist}, color: "${hex}"
for (let gy = 0; gy < 7; gy++) {
  for (let gx = 0; gx < 7; gx++) {
    const dx = gx-3, dy = gy-3;
    const dist = Math.sqrt(dx*dx+dy*dy);
    if (dist < 0.3 || dist > 3.6) continue;
    const angle = Math.atan2(dy, dx);
    const wave = (Math.sin(angle*${p.arms} - dist*${p.twist} + t*${p.speed}) + 1) / 2;
    setCell(gx, gy, wave * (1-dist/4) * 0.9);
  }
}
setCell(3, 3, 0.5 + Math.sin(t*3)*0.2);`;
  },
},

Infinity: {
  desc: "Snake of pixels traces a figure-8 path",
  params: {
    speed:  { min: 1, max: 20, step: 0.5, default: 9 },
    length: { min: 2, max: 16, step: 1, default: 8 },
  },
  _path: null,
  fn(t, p, c) {
    const cells = new Map();
    if (!this._path) {
      const path = []; let lastKey = null;
      for (let i = 0; i < 800; i++) {
        const a = (i/800)*Math.PI*2;
        const s = Math.sin(a), co = Math.cos(a), d = 1+s*s;
        const gx = Math.round(CENTER + CENTER*0.95*co/d);
        const gy = Math.round(CENTER + CENTER*0.7*s*co/d);
        const key = gx+","+gy;
        if (key !== lastKey) { path.push({x:gx,y:gy}); lastKey = key; }
      }
      while (path.length>1 && path[path.length-1].x===path[0].x && path[path.length-1].y===path[0].y) path.pop();
      this._path = path;
    }
    const path = this._path, len = path.length;
    const head = (t * p.speed) % len;
    for (let i = 0; i < p.length; i++) {
      const idx = ((Math.floor(head)-i) % len + len) % len;
      const cell = path[idx], key = cell.x+","+cell.y;
      const b = 1 - i/p.length;
      const ex = cells.get(key);
      if (!ex || ex.brightness < b) cells.set(key, col(c, b));
    }
    return cells;
  },
  code(p, hex) {
    return `// Infinity — speed: ${p.speed}, length: ${p.length}, color: "${hex}"
// Pre-compute lemniscate path on 7x7 grid (do once)
const path = []; let lastKey = null;
for (let i = 0; i < 800; i++) {
  const a = (i/800)*Math.PI*2;
  const s = Math.sin(a), c = Math.cos(a), d = 1+s*s;
  const gx = Math.round(3 + 2.85*c/d);
  const gy = Math.round(3 + 2.1*s*c/d);
  const key = gx+","+gy;
  if (key !== lastKey) { path.push({x:gx,y:gy}); lastKey = key; }
}
const head = (t * ${p.speed}) % path.length;
for (let i = 0; i < ${p.length}; i++) {
  const idx = ((Math.floor(head)-i) % path.length + path.length) % path.length;
  setCell(path[idx].x, path[idx].y, 1 - i/${p.length});
}`;
  },
},

Flicker: {
  desc: "Organic firefly-like pattern of cells flickering",
  params: {
    speed:     { min: 0.3, max: 5, step: 0.1, default: 1.7 },
    density:   { min: 0.5, max: 2, step: 0.1, default: 1.3 },
    threshold: { min: 0, max: 0.5, step: 0.05, default: 0.1 },
  },
  fn(t, p, c) {
    const cells = new Map();
    const s = p.speed;
    for (let gy = 0; gy < GRID; gy++) {
      for (let gx = 0; gx < GRID; gx++) {
        const v = (Math.sin(gx*2.1+t*s) + Math.sin(gy*2.7+t*s*1.35) + Math.sin((gx+gy)*1.4+t*s*0.65) + Math.sin((gx-gy)*1.8+t*s*1.65)) / 4;
        const b = Math.max(0, v * p.density) * 0.85;
        if (b > p.threshold) cells.set(gx+","+gy, col(c, b));
      }
    }
    return cells;
  },
  code(p, hex) {
    return `// Flicker — speed: ${p.speed}, density: ${p.density}, threshold: ${p.threshold}, color: "${hex}"
const s = ${p.speed};
for (let gy = 0; gy < 7; gy++) {
  for (let gx = 0; gx < 7; gx++) {
    const v = (
      Math.sin(gx*2.1 + t*s) +
      Math.sin(gy*2.7 + t*s*1.35) +
      Math.sin((gx+gy)*1.4 + t*s*0.65) +
      Math.sin((gx-gy)*1.8 + t*s*1.65)
    ) / 4;
    const b = Math.max(0, v * ${p.density}) * 0.85;
    if (b > ${p.threshold}) setCell(gx, gy, b);
  }
}`;
  },
},

Plasma: {
  desc: "Classic plasma effect — overlapping sine fields create organic blobs",
  params: {
    speed:  { min: 0.3, max: 5, step: 0.1, default: 1.5 },
    scale1: { min: 0.3, max: 2, step: 0.1, default: 0.8 },
    scale2: { min: 0.3, max: 2, step: 0.1, default: 0.6 },
  },
  fn(t, p, c) {
    const cells = new Map();
    for (let gy = 0; gy < GRID; gy++) {
      for (let gx = 0; gx < GRID; gx++) {
        const v1 = Math.sin(gx * p.scale1 + t * p.speed);
        const v2 = Math.sin(gy * p.scale2 + t * p.speed * 1.3);
        const v3 = Math.sin((gx + gy) * 0.5 + t * p.speed * 0.7);
        const v4 = Math.sin(Math.sqrt((gx-3)*(gx-3)+(gy-3)*(gy-3)) * 1.2 - t * p.speed * 0.9);
        const b = ((v1 + v2 + v3 + v4) / 4 + 1) / 2;
        if (b > 0.15) cells.set(gx+","+gy, col(c, b * 0.9));
      }
    }
    return cells;
  },
  code(p, hex) {
    return `// Plasma — speed: ${p.speed}, scale1: ${p.scale1}, scale2: ${p.scale2}, color: "${hex}"
for (let gy = 0; gy < 7; gy++) {
  for (let gx = 0; gx < 7; gx++) {
    const v1 = Math.sin(gx * ${p.scale1} + t * ${p.speed});
    const v2 = Math.sin(gy * ${p.scale2} + t * ${p.speed} * 1.3);
    const v3 = Math.sin((gx + gy) * 0.5 + t * ${p.speed} * 0.7);
    const v4 = Math.sin(Math.sqrt((gx-3)**2+(gy-3)**2) * 1.2 - t * ${p.speed} * 0.9);
    const b = ((v1 + v2 + v3 + v4) / 4 + 1) / 2;
    if (b > 0.15) setCell(gx, gy, b * 0.9);
  }
}`;
  },
},

DNA: {
  desc: "Double helix — two sine strands twist around each other vertically",
  params: {
    speed:  { min: 0.5, max: 5, step: 0.1, default: 2.5 },
    twist:  { min: 0.5, max: 3, step: 0.1, default: 1.4 },
    spread: { min: 0.5, max: 2.5, step: 0.1, default: 1.5 },
  },
  fn(t, p, c) {
    const cells = new Map();
    for (let gy = 0; gy < GRID; gy++) {
      const x1 = CENTER + Math.sin(gy * p.twist - t * p.speed) * p.spread;
      const x2 = CENTER + Math.sin(gy * p.twist - t * p.speed + Math.PI) * p.spread;
      for (let gx = 0; gx < GRID; gx++) {
        const d1 = Math.abs(gx - x1);
        const d2 = Math.abs(gx - x2);
        const b1 = d1 < 1.2 ? Math.max(0, 1 - d1 * 0.8) : 0;
        const b2 = d2 < 1.2 ? Math.max(0, 1 - d2 * 0.8) : 0;
        const b = Math.max(b1, b2);
        // Cross-links between strands
        const midX = (x1 + x2) / 2;
        const halfDist = Math.abs(x1 - x2) / 2;
        const onRung = (gy % 2 === 0) && Math.abs(gx - midX) < halfDist && halfDist > 0.5;
        const bRung = onRung ? 0.3 * (1 - Math.abs(gx - midX) / halfDist) : 0;
        const total = Math.min(1, Math.max(b, bRung));
        if (total > 0.05) cells.set(gx+","+gy, col(c, total * 0.9));
      }
    }
    return cells;
  },
  code(p, hex) {
    return `// DNA — speed: ${p.speed}, twist: ${p.twist}, spread: ${p.spread}, color: "${hex}"
for (let gy = 0; gy < 7; gy++) {
  const x1 = 3 + Math.sin(gy * ${p.twist} - t * ${p.speed}) * ${p.spread};
  const x2 = 3 + Math.sin(gy * ${p.twist} - t * ${p.speed} + Math.PI) * ${p.spread};
  for (let gx = 0; gx < 7; gx++) {
    const d1 = Math.abs(gx - x1), d2 = Math.abs(gx - x2);
    const b1 = d1 < 1.2 ? Math.max(0, 1-d1*0.8) : 0;
    const b2 = d2 < 1.2 ? Math.max(0, 1-d2*0.8) : 0;
    const b = Math.max(b1, b2);
    const midX = (x1+x2)/2, half = Math.abs(x1-x2)/2;
    const rung = (gy%2===0 && Math.abs(gx-midX)<half && half>0.5) ? 0.3*(1-Math.abs(gx-midX)/half) : 0;
    const total = Math.min(1, Math.max(b, rung));
    if (total > 0.05) setCell(gx, gy, total * 0.9);
  }
}`;
  },
},

Vortex: {
  desc: "Pixels spiral inward toward center like a whirlpool drain",
  params: {
    speed:  { min: 0.5, max: 5, step: 0.1, default: 2.5 },
    tightness: { min: 0.3, max: 2, step: 0.1, default: 0.8 },
    falloff: { min: 0.1, max: 0.5, step: 0.05, default: 0.25 },
  },
  fn(t, p, c) {
    const cells = new Map();
    for (let gy = 0; gy < GRID; gy++) {
      for (let gx = 0; gx < GRID; gx++) {
        const dx = gx - CENTER, dy = gy - CENTER;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < 0.1) { cells.set(gx+","+gy, col(c, 0.8)); continue; }
        const angle = Math.atan2(dy, dx);
        const spiral = Math.sin(angle - dist * p.tightness + t * p.speed);
        const b = Math.max(0, spiral) * Math.exp(-dist * p.falloff) * 0.95;
        if (b > 0.04) cells.set(gx+","+gy, col(c, b));
      }
    }
    return cells;
  },
  code(p, hex) {
    return `// Vortex — speed: ${p.speed}, tightness: ${p.tightness}, falloff: ${p.falloff}, color: "${hex}"
for (let gy = 0; gy < 7; gy++) {
  for (let gx = 0; gx < 7; gx++) {
    const dx = gx-3, dy = gy-3;
    const dist = Math.sqrt(dx*dx+dy*dy);
    if (dist < 0.1) { setCell(gx, gy, 0.8); continue; }
    const angle = Math.atan2(dy, dx);
    const spiral = Math.sin(angle - dist*${p.tightness} + t*${p.speed});
    const b = Math.max(0, spiral) * Math.exp(-dist*${p.falloff}) * 0.95;
    if (b > 0.04) setCell(gx, gy, b);
  }
}`;
  },
},

Meteor: {
  desc: "Diagonal streaks rain down like a meteor shower",
  params: {
    speed:  { min: 1, max: 10, step: 0.5, default: 5 },
    trails: { min: 1, max: 5, step: 1, default: 3 },
    length: { min: 1, max: 4, step: 0.5, default: 2.5 },
  },
  fn(t, p, c) {
    const cells = new Map();
    for (let i = 0; i < p.trails; i++) {
      const phase = (t * p.speed + i * 4.7) % 12;
      const headX = phase - 2;
      const headY = phase - 2 + i * 1.3;
      for (let j = 0; j < p.length * 2; j++) {
        const mx = Math.round(headX - j * 0.5);
        const my = Math.round(headY - j * 0.5);
        if (mx < 0 || mx >= GRID || my < 0 || my >= GRID) continue;
        const b = Math.max(0, 1 - j / (p.length * 2)) * 0.9;
        const key = mx+","+my;
        const ex = cells.get(key);
        if (!ex || ex.brightness < b) cells.set(key, col(c, b));
      }
    }
    return cells;
  },
  code(p, hex) {
    return `// Meteor — speed: ${p.speed}, trails: ${p.trails}, length: ${p.length}, color: "${hex}"
for (let i = 0; i < ${p.trails}; i++) {
  const phase = (t * ${p.speed} + i * 4.7) % 12;
  const headX = phase - 2, headY = phase - 2 + i * 1.3;
  for (let j = 0; j < ${p.length*2}; j++) {
    const mx = Math.round(headX - j*0.5), my = Math.round(headY - j*0.5);
    if (mx<0||mx>=7||my<0||my>=7) continue;
    setCell(mx, my, Math.max(0, 1 - j/${p.length*2}) * 0.9);
  }
}`;
  },
},

Scanner: {
  desc: "Line scans back and forth across the grid like a barcode reader",
  params: {
    speed:  { min: 0.5, max: 5, step: 0.1, default: 2 },
    width:  { min: 0.3, max: 2, step: 0.1, default: 0.8 },
    vertical: { min: 0, max: 1, step: 1, default: 0 },
  },
  fn(t, p, c) {
    const cells = new Map();
    const pos = CENTER + Math.sin(t * p.speed) * CENTER;
    for (let gy = 0; gy < GRID; gy++) {
      for (let gx = 0; gx < GRID; gx++) {
        const dist = p.vertical ? Math.abs(gy - pos) : Math.abs(gx - pos);
        if (dist > 2) continue;
        const b = Math.max(0, 1 - dist * p.width) * 0.9;
        if (b > 0.03) cells.set(gx+","+gy, col(c, b));
      }
    }
    return cells;
  },
  code(p, hex) {
    const axis = p.vertical ? "gy" : "gx";
    return `// Scanner — speed: ${p.speed}, width: ${p.width}, ${p.vertical?"vertical":"horizontal"}, color: "${hex}"
const pos = 3 + Math.sin(t * ${p.speed}) * 3;
for (let gy = 0; gy < 7; gy++) {
  for (let gx = 0; gx < 7; gx++) {
    const dist = Math.abs(${axis} - pos);
    if (dist > 2) continue;
    const b = Math.max(0, 1 - dist * ${p.width}) * 0.9;
    if (b > 0.03) setCell(gx, gy, b);
  }
}`;
  },
},

Heartbeat: {
  desc: "EKG-style pulse line with sharp spikes",
  params: {
    speed: { min: 0.5, max: 4, step: 0.1, default: 1.5 },
    spike: { min: 1, max: 3, step: 0.1, default: 2.5 },
    rest:  { min: 0.3, max: 2, step: 0.1, default: 0.6 },
  },
  fn(t, p, c) {
    const cells = new Map();
    for (let gx = 0; gx < GRID; gx++) {
      const phase = (gx * 0.4 - t * p.speed * 3) % (Math.PI * 2);
      const normPhase = ((phase % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);
      let y;
      if (normPhase < 0.8) {
        y = CENTER;
      } else if (normPhase < 1.2) {
        y = CENTER - p.spike * Math.sin((normPhase - 0.8) / 0.4 * Math.PI);
      } else if (normPhase < 1.6) {
        y = CENTER + p.spike * 0.4 * Math.sin((normPhase - 1.2) / 0.4 * Math.PI);
      } else {
        y = CENTER;
      }
      for (let gy = 0; gy < GRID; gy++) {
        const dist = Math.abs(gy - y);
        if (dist > 1.2) continue;
        const b = Math.max(0, 1 - dist * p.rest) * 0.9;
        if (b > 0.03) cells.set(gx+","+gy, col(c, b));
      }
    }
    return cells;
  },
  code(p, hex) {
    return `// Heartbeat — speed: ${p.speed}, spike: ${p.spike}, rest: ${p.rest}, color: "${hex}"
for (let gx = 0; gx < 7; gx++) {
  const phase = ((gx*0.4 - t*${p.speed}*3) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);
  let y = 3;
  if (phase >= 0.8 && phase < 1.2) y = 3 - ${p.spike}*Math.sin((phase-0.8)/0.4*Math.PI);
  else if (phase >= 1.2 && phase < 1.6) y = 3 + ${p.spike}*0.4*Math.sin((phase-1.2)/0.4*Math.PI);
  for (let gy = 0; gy < 7; gy++) {
    const dist = Math.abs(gy - y);
    if (dist > 1.2) continue;
    setCell(gx, gy, Math.max(0, 1 - dist*${p.rest}) * 0.9);
  }
}`;
  },
},

Rain: {
  desc: "Columns of light drip downward like digital rain",
  params: {
    speed:   { min: 1, max: 8, step: 0.5, default: 4 },
    density: { min: 0.2, max: 0.8, step: 0.05, default: 0.45 },
    length:  { min: 1, max: 4, step: 0.5, default: 2.5 },
  },
  _seeds: null,
  fn(t, p, c) {
    if (!this._seeds) {
      this._seeds = [];
      for (let i = 0; i < GRID; i++) this._seeds.push(Math.random() * 10);
    }
    const cells = new Map();
    for (let gx = 0; gx < GRID; gx++) {
      const offset = this._seeds[gx];
      const period = 2 + (1 - p.density) * 3;
      const head = ((t * p.speed + offset) % period) / period * (GRID + p.length * 2) - p.length;
      for (let gy = 0; gy < GRID; gy++) {
        const dist = head - gy;
        if (dist < 0 || dist > p.length * 2) continue;
        const b = Math.max(0, 1 - dist / (p.length * 2)) * 0.9;
        if (b > 0.03) cells.set(gx+","+gy, col(c, b));
      }
    }
    return cells;
  },
  code(p, hex) {
    return `// Rain — speed: ${p.speed}, density: ${p.density}, length: ${p.length}, color: "${hex}"
// Needs per-column random offsets (compute once)
for (let gx = 0; gx < 7; gx++) {
  const offset = columnSeeds[gx]; // pre-random per column
  const period = ${(2 + (1 - p.density) * 3).toFixed(1)};
  const head = ((t * ${p.speed} + offset) % period) / period * ${(GRID + p.length * 2).toFixed(1)} - ${p.length};
  for (let gy = 0; gy < 7; gy++) {
    const dist = head - gy;
    if (dist < 0 || dist > ${p.length * 2}) continue;
    setCell(gx, gy, Math.max(0, 1 - dist/${p.length * 2}) * 0.9);
  }
}`;
  },
},

Atom: {
  desc: "Electron orbits around a nucleus in multiple tilted planes",
  params: {
    speed:  { min: 0.5, max: 5, step: 0.1, default: 2.5 },
    orbits: { min: 2, max: 4, step: 1, default: 3 },
    radius: { min: 1.5, max: 3, step: 0.1, default: 2.5 },
  },
  fn(t, p, c) {
    const cells = new Map();
    // Nucleus
    cells.set(CENTER+","+CENTER, col(c, 0.7 + Math.sin(t * 4) * 0.15));
    for (let i = 0; i < p.orbits; i++) {
      const tilt = (i / p.orbits) * Math.PI;
      const angle = t * p.speed * (1 + i * 0.2) + i * 2;
      // Draw the orbit ring faintly
      for (let step = 0; step < 20; step++) {
        const a = (step / 20) * Math.PI * 2;
        const ox = Math.cos(a) * p.radius;
        const oy = Math.sin(a) * p.radius * Math.cos(tilt);
        const gx = Math.round(CENTER + ox);
        const gy = Math.round(CENTER + oy);
        if (gx < 0 || gx >= GRID || gy < 0 || gy >= GRID) continue;
        const key = gx+","+gy;
        const ex = cells.get(key);
        if (!ex || ex.brightness < 0.12) cells.set(key, col(c, 0.12));
      }
      // Electron
      const ex = CENTER + Math.cos(angle) * p.radius;
      const ey = CENTER + Math.sin(angle) * p.radius * Math.cos(tilt);
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = Math.round(ex) + dx;
          const ny = Math.round(ey) + dy;
          if (nx < 0 || nx >= GRID || ny < 0 || ny >= GRID) continue;
          const dist = Math.sqrt((ex-nx)**2 + (ey-ny)**2);
          const b = Math.max(0, 1 - dist * 0.7) * 0.95;
          if (b > 0.05) {
            const key = nx+","+ny;
            const existing = cells.get(key);
            if (!existing || existing.brightness < b) cells.set(key, col(c, b));
          }
        }
      }
    }
    return cells;
  },
  code(p, hex) {
    return `// Atom — speed: ${p.speed}, orbits: ${p.orbits}, radius: ${p.radius}, color: "${hex}"
setCell(3, 3, 0.7 + Math.sin(t*4)*0.15);
for (let i = 0; i < ${p.orbits}; i++) {
  const tilt = (i/${p.orbits}) * Math.PI;
  const angle = t * ${p.speed} * (1 + i*0.2) + i*2;
  const ex = 3 + Math.cos(angle) * ${p.radius};
  const ey = 3 + Math.sin(angle) * ${p.radius} * Math.cos(tilt);
  // electron with soft falloff
  for (let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++) {
    const nx=Math.round(ex)+dx, ny=Math.round(ey)+dy;
    if(nx<0||nx>=7||ny<0||ny>=7) continue;
    setCell(nx, ny, Math.max(0, 1-Math.sqrt((ex-nx)**2+(ey-ny)**2)*0.7)*0.95);
  }
}`;
  },
},

Fire: {
  desc: "Flame-like effect rising upward with flickering intensity",
  params: {
    speed:   { min: 0.5, max: 5, step: 0.1, default: 3 },
    width:   { min: 1, max: 3, step: 0.1, default: 2 },
    height:  { min: 2, max: 6, step: 0.5, default: 5 },
  },
  fn(t, p, c) {
    const cells = new Map();
    for (let gy = 0; gy < GRID; gy++) {
      for (let gx = 0; gx < GRID; gx++) {
        const fromBottom = (GRID - 1 - gy);
        const heightFactor = Math.max(0, 1 - fromBottom / p.height);
        const centerDist = Math.abs(gx - CENTER);
        const widthFade = Math.max(0, 1 - centerDist / p.width);
        // Noise-like flicker using multiple sine waves
        const flicker = (
          Math.sin(gx * 2.3 + t * p.speed * 2.1 + gy * 0.7) * 0.3 +
          Math.sin(gy * 1.7 - t * p.speed * 3.2 + gx * 1.1) * 0.3 +
          Math.sin((gx + gy) * 1.5 + t * p.speed * 1.7) * 0.2 +
          0.5
        );
        const b = heightFactor * widthFade * flicker;
        if (b > 0.05) cells.set(gx+","+gy, col(c, Math.min(1, b)));
      }
    }
    return cells;
  },
  code(p, hex) {
    return `// Fire — speed: ${p.speed}, width: ${p.width}, height: ${p.height}, color: "${hex}"
for (let gy = 0; gy < 7; gy++) {
  for (let gx = 0; gx < 7; gx++) {
    const fromBottom = 6 - gy;
    const hFactor = Math.max(0, 1 - fromBottom/${p.height});
    const wFade = Math.max(0, 1 - Math.abs(gx-3)/${p.width});
    const flicker = Math.sin(gx*2.3+t*${p.speed}*2.1+gy*0.7)*0.3 + Math.sin(gy*1.7-t*${p.speed}*3.2+gx*1.1)*0.3 + Math.sin((gx+gy)*1.5+t*${p.speed}*1.7)*0.2 + 0.5;
    const b = hFactor * wFade * flicker;
    if (b > 0.05) setCell(gx, gy, Math.min(1, b));
  }
}`;
  },
},

Pinwheel: {
  desc: "Rotating pinwheel with alternating bright/dark sectors",
  params: {
    speed:   { min: 0.3, max: 4, step: 0.1, default: 1.5 },
    blades:  { min: 2, max: 6, step: 1, default: 4 },
    curve:   { min: 0, max: 2, step: 0.1, default: 0.5 },
  },
  fn(t, p, c) {
    const cells = new Map();
    for (let gy = 0; gy < GRID; gy++) {
      for (let gx = 0; gx < GRID; gx++) {
        const dx = gx - CENTER, dy = gy - CENTER;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < 0.3) { cells.set(gx+","+gy, col(c, 0.6)); continue; }
        if (dist > 3.6) continue;
        const angle = Math.atan2(dy, dx) + dist * p.curve;
        const sector = (Math.sin(angle * p.blades - t * p.speed * 3) + 1) / 2;
        const b = sector * (1 - dist / 4.5) * 0.9;
        if (b > 0.04) cells.set(gx+","+gy, col(c, b));
      }
    }
    return cells;
  },
  code(p, hex) {
    return `// Pinwheel — speed: ${p.speed}, blades: ${p.blades}, curve: ${p.curve}, color: "${hex}"
for (let gy = 0; gy < 7; gy++) {
  for (let gx = 0; gx < 7; gx++) {
    const dx = gx-3, dy = gy-3;
    const dist = Math.sqrt(dx*dx+dy*dy);
    if (dist < 0.3) { setCell(gx, gy, 0.6); continue; }
    if (dist > 3.6) continue;
    const angle = Math.atan2(dy, dx) + dist * ${p.curve};
    const sector = (Math.sin(angle * ${p.blades} - t * ${p.speed} * 3) + 1) / 2;
    setCell(gx, gy, sector * (1-dist/4.5) * 0.9);
  }
}`;
  },
},

Bounce: {
  desc: "A bright dot bounces around inside the grid with trail",
  params: {
    speed: { min: 0.5, max: 4, step: 0.1, default: 1.8 },
    trail: { min: 1, max: 5, step: 0.5, default: 3 },
    glow:  { min: 0.5, max: 2, step: 0.1, default: 1.2 },
  },
  fn(t, p, c) {
    const cells = new Map();
    // Lissajous bounce
    const fx = CENTER + Math.sin(t * p.speed * 1.7) * 2.5;
    const fy = CENTER + Math.sin(t * p.speed * 2.3) * 2.5;
    for (let gy = 0; gy < GRID; gy++) {
      for (let gx = 0; gx < GRID; gx++) {
        const dist = Math.sqrt((gx-fx)**2 + (gy-fy)**2);
        if (dist > p.glow + 1) continue;
        const b = Math.max(0, 1 - dist / p.glow) * 0.95;
        if (b > 0.03) cells.set(gx+","+gy, col(c, b));
      }
    }
    // Ghost trail
    for (let i = 1; i <= 3; i++) {
      const tt = t - i * 0.08 * p.trail;
      const gfx = CENTER + Math.sin(tt * p.speed * 1.7) * 2.5;
      const gfy = CENTER + Math.sin(tt * p.speed * 2.3) * 2.5;
      const gx = Math.round(gfx), gy = Math.round(gfy);
      if (gx >= 0 && gx < GRID && gy >= 0 && gy < GRID) {
        const key = gx+","+gy;
        const fade = 0.4 * (1 - i / 4);
        const ex = cells.get(key);
        if (!ex || ex.brightness < fade) cells.set(key, col(c, fade));
      }
    }
    return cells;
  },
  code(p, hex) {
    return `// Bounce — speed: ${p.speed}, trail: ${p.trail}, glow: ${p.glow}, color: "${hex}"
const fx = 3 + Math.sin(t * ${p.speed} * 1.7) * 2.5;
const fy = 3 + Math.sin(t * ${p.speed} * 2.3) * 2.5;
for (let gy = 0; gy < 7; gy++) {
  for (let gx = 0; gx < 7; gx++) {
    const dist = Math.sqrt((gx-fx)**2 + (gy-fy)**2);
    if (dist > ${p.glow}+1) continue;
    const b = Math.max(0, 1 - dist/${p.glow}) * 0.95;
    if (b > 0.03) setCell(gx, gy, b);
  }
}`;
  },
},

Rings: {
  desc: "Concentric circular rings expand outward continuously",
  params: {
    speed:   { min: 0.5, max: 4, step: 0.1, default: 2 },
    spacing: { min: 1, max: 4, step: 0.5, default: 2.5 },
    width:   { min: 0.2, max: 1, step: 0.1, default: 0.5 },
  },
  fn(t, p, c) {
    const cells = new Map();
    for (let gy = 0; gy < GRID; gy++) {
      for (let gx = 0; gx < GRID; gx++) {
        const dx = gx - CENTER, dy = gy - CENTER;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const wave = Math.sin((dist - t * p.speed) * Math.PI * 2 / p.spacing);
        const b = Math.max(0, wave) * Math.exp(-dist * 0.15) * 0.9;
        if (b > 0.04) cells.set(gx+","+gy, col(c, b));
      }
    }
    return cells;
  },
  code(p, hex) {
    return `// Rings — speed: ${p.speed}, spacing: ${p.spacing}, width: ${p.width}, color: "${hex}"
for (let gy = 0; gy < 7; gy++) {
  for (let gx = 0; gx < 7; gx++) {
    const dx = gx-3, dy = gy-3;
    const dist = Math.sqrt(dx*dx+dy*dy);
    const wave = Math.sin((dist - t*${p.speed}) * Math.PI*2/${p.spacing});
    const b = Math.max(0, wave) * Math.exp(-dist*0.15) * 0.9;
    if (b > 0.04) setCell(gx, gy, b);
  }
}`;
  },
},

Crosshair: {
  desc: "Rotating cross/plus shape that pulses",
  params: {
    speed: { min: 0.3, max: 4, step: 0.1, default: 1.2 },
    width: { min: 0.3, max: 1.5, step: 0.1, default: 0.6 },
    pulse: { min: 0, max: 3, step: 0.1, default: 1.5 },
  },
  fn(t, p, c) {
    const cells = new Map();
    const angle = t * p.speed;
    const pulseBr = 0.6 + Math.sin(t * p.pulse) * 0.3;
    for (let gy = 0; gy < GRID; gy++) {
      for (let gx = 0; gx < GRID; gx++) {
        const dx = gx - CENTER, dy = gy - CENTER;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < 0.1) { cells.set(gx+","+gy, col(c, 0.8)); continue; }
        if (dist > 3.6) continue;
        // Rotate coordinates
        const rx = dx * Math.cos(angle) + dy * Math.sin(angle);
        const ry = -dx * Math.sin(angle) + dy * Math.cos(angle);
        // Cross shape: close to either axis
        const crossDist = Math.min(Math.abs(rx), Math.abs(ry));
        if (crossDist > p.width) continue;
        const b = (1 - crossDist / p.width) * (1 - dist / 4) * pulseBr;
        if (b > 0.04) cells.set(gx+","+gy, col(c, b));
      }
    }
    return cells;
  },
  code(p, hex) {
    return `// Crosshair — speed: ${p.speed}, width: ${p.width}, pulse: ${p.pulse}, color: "${hex}"
const angle = t * ${p.speed};
const pulseBr = 0.6 + Math.sin(t * ${p.pulse}) * 0.3;
for (let gy = 0; gy < 7; gy++) {
  for (let gx = 0; gx < 7; gx++) {
    const dx = gx-3, dy = gy-3;
    const dist = Math.sqrt(dx*dx+dy*dy);
    if (dist < 0.1) { setCell(gx, gy, 0.8); continue; }
    if (dist > 3.6) continue;
    const rx = dx*Math.cos(angle)+dy*Math.sin(angle);
    const ry = -dx*Math.sin(angle)+dy*Math.cos(angle);
    const crossDist = Math.min(Math.abs(rx), Math.abs(ry));
    if (crossDist > ${p.width}) continue;
    setCell(gx, gy, (1-crossDist/${p.width}) * (1-dist/4) * pulseBr);
  }
}`;
  },
},

Cascade: {
  desc: "Rows light up in sequence cascading down then back up",
  params: {
    speed:  { min: 0.5, max: 5, step: 0.1, default: 2.5 },
    spread: { min: 0.5, max: 3, step: 0.1, default: 1.5 },
    fade:   { min: 0.3, max: 1, step: 0.05, default: 0.6 },
  },
  fn(t, p, c) {
    const cells = new Map();
    const pos = CENTER + Math.sin(t * p.speed) * CENTER;
    for (let gy = 0; gy < GRID; gy++) {
      const dist = Math.abs(gy - pos);
      if (dist > p.spread + 1) continue;
      const rowBr = Math.max(0, 1 - dist / p.spread) * 0.9;
      for (let gx = 0; gx < GRID; gx++) {
        const centerFade = 1 - Math.abs(gx - CENTER) / (CENTER + 1) * (1 - p.fade);
        const b = rowBr * centerFade;
        if (b > 0.03) cells.set(gx+","+gy, col(c, b));
      }
    }
    return cells;
  },
  code(p, hex) {
    return `// Cascade — speed: ${p.speed}, spread: ${p.spread}, fade: ${p.fade}, color: "${hex}"
const pos = 3 + Math.sin(t * ${p.speed}) * 3;
for (let gy = 0; gy < 7; gy++) {
  const dist = Math.abs(gy - pos);
  if (dist > ${p.spread} + 1) continue;
  const rowBr = Math.max(0, 1 - dist/${p.spread}) * 0.9;
  for (let gx = 0; gx < 7; gx++) {
    const b = rowBr * (1 - Math.abs(gx-3)/4 * ${(1-p.fade).toFixed(1)});
    if (b > 0.03) setCell(gx, gy, b);
  }
}`;
  },
},

Warp: {
  desc: "Star-warp effect — dots stretch outward from center",
  params: {
    speed:  { min: 0.5, max: 5, step: 0.1, default: 2.5 },
    rays:   { min: 3, max: 8, step: 1, default: 5 },
    length: { min: 0.5, max: 2, step: 0.1, default: 1.2 },
  },
  fn(t, p, c) {
    const cells = new Map();
    cells.set(CENTER+","+CENTER, col(c, 0.3));
    for (let i = 0; i < p.rays; i++) {
      const baseAngle = (i / p.rays) * Math.PI * 2;
      const rayPhase = (t * p.speed + i * 0.7) % 2;
      const rayDist = rayPhase * 3.5;
      for (let j = 0; j < 4; j++) {
        const d = rayDist - j * 0.3 * p.length;
        if (d < 0.5 || d > 3.5) continue;
        const gx = Math.round(CENTER + Math.cos(baseAngle) * d);
        const gy = Math.round(CENTER + Math.sin(baseAngle) * d);
        if (gx < 0 || gx >= GRID || gy < 0 || gy >= GRID) continue;
        const b = (1 - j / 4) * 0.85 * Math.min(1, d / 1.5);
        const key = gx+","+gy;
        const ex = cells.get(key);
        if (!ex || ex.brightness < b) cells.set(key, col(c, b));
      }
    }
    return cells;
  },
  code(p, hex) {
    return `// Warp — speed: ${p.speed}, rays: ${p.rays}, length: ${p.length}, color: "${hex}"
setCell(3, 3, 0.3);
for (let i = 0; i < ${p.rays}; i++) {
  const angle = (i/${p.rays}) * Math.PI * 2;
  const phase = (t * ${p.speed} + i*0.7) % 2;
  const rayDist = phase * 3.5;
  for (let j = 0; j < 4; j++) {
    const d = rayDist - j * 0.3 * ${p.length};
    if (d < 0.5 || d > 3.5) continue;
    const gx = Math.round(3 + Math.cos(angle)*d);
    const gy = Math.round(3 + Math.sin(angle)*d);
    if (gx<0||gx>=7||gy<0||gy>=7) continue;
    setCell(gx, gy, (1-j/4) * 0.85 * Math.min(1, d/1.5));
  }
}`;
  },
},

Conway: {
  desc: "Pseudo-cellular automata — patterns shift like Game of Life",
  params: {
    speed:     { min: 0.3, max: 3, step: 0.1, default: 0.8 },
    threshold: { min: 0.3, max: 0.7, step: 0.05, default: 0.48 },
    smooth:    { min: 0.1, max: 1, step: 0.1, default: 0.4 },
  },
  fn(t, p, c) {
    const cells = new Map();
    const frame = t * p.speed;
    for (let gy = 0; gy < GRID; gy++) {
      for (let gx = 0; gx < GRID; gx++) {
        // Smooth noise field that creates life-like patterns
        const n1 = Math.sin(gx * 1.1 + frame * 2.3) * Math.cos(gy * 1.3 + frame * 1.7);
        const n2 = Math.sin((gx+gy) * 0.8 + frame * 1.1) * Math.cos((gx-gy) * 0.9 + frame * 2.1);
        const n3 = Math.sin(gx * 2.1 - frame * 1.5) * Math.sin(gy * 1.7 + frame * 0.9);
        const v = (n1 + n2 + n3) / 3;
        if (v > p.threshold - 0.5) {
          const b = Math.min(1, (v - (p.threshold - 0.5)) / p.smooth) * 0.85;
          if (b > 0.04) cells.set(gx+","+gy, col(c, b));
        }
      }
    }
    return cells;
  },
  code(p, hex) {
    return `// Conway — speed: ${p.speed}, threshold: ${p.threshold}, smooth: ${p.smooth}, color: "${hex}"
const frame = t * ${p.speed};
for (let gy = 0; gy < 7; gy++) {
  for (let gx = 0; gx < 7; gx++) {
    const n1 = Math.sin(gx*1.1+frame*2.3) * Math.cos(gy*1.3+frame*1.7);
    const n2 = Math.sin((gx+gy)*0.8+frame*1.1) * Math.cos((gx-gy)*0.9+frame*2.1);
    const n3 = Math.sin(gx*2.1-frame*1.5) * Math.sin(gy*1.7+frame*0.9);
    const v = (n1+n2+n3) / 3;
    if (v > ${p.threshold - 0.5}) {
      const b = Math.min(1, (v - ${(p.threshold - 0.5).toFixed(2)}) / ${p.smooth}) * 0.85;
      if (b > 0.04) setCell(gx, gy, b);
    }
  }
}`;
  },
},

};


// ============================================================
// BUILD UI
// ============================================================
const container = document.getElementById("cards");
const cardStates = []; // per-card mutable state

for (const [name, def] of Object.entries(ANIM_DEFS)) {
  const state = {
    name,
    def,
    color: hexToRgb("#ffd232"),
    hex: "#ffd232",
    params: {},
    canvases: [],
    playing: false,
    cardEl: null,
  };
  // Init params from defaults
  for (const [k, v] of Object.entries(def.params)) state.params[k] = v.default;

  const card = document.createElement("div");
  card.className = "card paused";
  state.cardEl = card;

  // Header
  const header = document.createElement("div");
  header.className = "card-header";
  const h3 = document.createElement("h3");
  h3.textContent = name;
  header.appendChild(h3);
  const btnGroup = document.createElement("div");
  btnGroup.style.cssText = "display:flex;gap:5px;";
  const playBtn = document.createElement("button");
  playBtn.className = "play-btn";
  playBtn.textContent = "\u25B6 Play";
  playBtn.onclick = () => {
    state.playing = !state.playing;
    playBtn.textContent = state.playing ? "\u25A0 Stop" : "\u25B6 Play";
    playBtn.classList.toggle("playing", state.playing);
    card.classList.toggle("paused", !state.playing);
  };
  btnGroup.appendChild(playBtn);
  const copyBtn = document.createElement("button");
  copyBtn.className = "copy-btn";
  copyBtn.textContent = "Copy";
  copyBtn.onclick = () => {
    const code = def.code(state.params, state.hex);
    navigator.clipboard.writeText(code).then(() => {
      copyBtn.textContent = "Copied!";
      copyBtn.classList.add("copied");
      setTimeout(() => { copyBtn.textContent = "Copy"; copyBtn.classList.remove("copied"); }, 1500);
    });
  };
  btnGroup.appendChild(copyBtn);
  header.appendChild(btnGroup);
  card.appendChild(header);

  // Canvas sizes
  const sizes = document.createElement("div");
  sizes.className = "sizes";
  for (const sz of RENDER_SIZES) {
    const item = document.createElement("div");
    item.className = "item";
    const c = makeCanvas(sz);
    item.appendChild(c);
    const lbl = document.createElement("label");
    lbl.textContent = sz + "px";
    item.appendChild(lbl);
    sizes.appendChild(item);
    state.canvases.push({ canvas: c, size: sz });
  }
  card.appendChild(sizes);

  // Controls row
  const controls = document.createElement("div");
  controls.className = "controls-row";

  // Color picker
  const colorLabel = document.createElement("label");
  colorLabel.textContent = "Color ";
  const colorInput = document.createElement("input");
  colorInput.type = "color";
  colorInput.value = state.hex;
  colorInput.oninput = () => {
    state.hex = colorInput.value;
    state.color = hexToRgb(colorInput.value);
  };
  colorLabel.appendChild(colorInput);
  controls.appendChild(colorLabel);

  // Param sliders
  for (const [pName, pDef] of Object.entries(def.params)) {
    const label = document.createElement("label");
    label.textContent = pName.charAt(0).toUpperCase() + pName.slice(1) + " ";
    const slider = document.createElement("input");
    slider.type = "range";
    slider.min = pDef.min;
    slider.max = pDef.max;
    slider.step = pDef.step;
    slider.value = pDef.default;
    const valSpan = document.createElement("span");
    valSpan.className = "val";
    valSpan.textContent = pDef.default;
    slider.oninput = () => {
      state.params[pName] = +slider.value;
      valSpan.textContent = slider.value;
    };
    label.appendChild(slider);
    label.appendChild(valSpan);
    controls.appendChild(label);
  }

  card.appendChild(controls);

  // Desc
  const desc = document.createElement("p");
  desc.textContent = def.desc;
  card.appendChild(desc);

  container.appendChild(card);
  cardStates.push(state);
}

// ============================================================
// ANIMATE
// ============================================================
let lastTime = 0;
let elapsed = 0;

function animate(time) {
  if (!lastTime) lastTime = time;
  const dt = Math.min(time - lastTime, 50) / 1000;
  lastTime = time;
  elapsed += dt;

  for (const state of cardStates) {
    if (!state.playing) continue;
    const cells = state.def.fn(elapsed, state.params, state.color);
    for (const { canvas, size } of state.canvases) {
      drawLEDGrid(canvas.getContext("2d"), size, cells);
    }
  }
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
</script>
</body>
</html>
